window.SIDEBAR_ITEMS = {"fn":[["bitrange_subset","Takes a specified subsequence of the little-endian bit representation of a field element. The bits are numbered from 0 for the LSB."],["bool_check","Checks that an expression is either 1 or 0."],["decompose_word","Decompose a word `alpha` into `window_num_bits` bits (little-endian) For a window size of `w`, this returns [k_0, …, k_n] where each `k_i` is a `w`-bit value, and `scalar = k_0 + k_1 * w + k_n * w^n`."],["i2lebsp","The sequence of bits representing a u64 in little-endian order."],["lebs2ip","The u64 integer represented by an L-bit little-endian bitstring."],["range_check","Check that an expression is in the small range [0..range), i.e. 0 ≤ word < range."],["ternary","If `a` then `b`, else `c`. Returns (a * b) + (1 - a) * c."]],"mod":[["cond_swap","Gadget and chip for a conditional swap utility."],["decompose_running_sum","Decomposes an $n$-bit field element $\\alpha$ into $W$ windows, each window being a $K$-bit word, using a running sum $z$. We constrain $K \\leq 3$ for this helper. $$\\alpha = k_0 + (2^K) k_1 + (2^{2K}) k_2 + … + (2^{(W-1)K}) k_{W-1}$$"],["lookup_range_check","Make use of a K-bit lookup table to decompose a field element into K-bit words."]],"struct":[["RangeConstrained","A type representing a range-constrained field element."]],"trait":[["FieldValue","A type that has a value at either keygen or proving time."],["UtilitiesInstructions","Trait for utilities used across circuits."],["Var","Trait for a variable in the circuit."]]};